#!/usr/bin/python3

# local_terminal header: /usr/bin/python3
# Amarel cluster header: /miniconda3/envs/dna/bin/python

import os, math, sys, copy, argparse
import numpy as np
import pandas as pd
path   = os.getcwd()
#dbpath = '/home/rty10/Documents/databases'
dbpath = '/home/rty10/Documents/nuc_database'

# --- CLI goal:
# --- python3 SCRIPT.py -ncpid             ... -nl        ... -bps                ... -bpf             ... -o
# --- python3 SCRIPT.py --nuc-core-part-id ... --ncp-size ... --starting-basepair ... --final-basepair ... --output-name

parser = argparse.ArgumentParser(prog="Nucleosome Parameters Generator",
                                 description="Generate a 3DNA-formatted parameters file of a nucleosome core particle of some specific length.\nCode Generated by Robert Young, Rutgers University, 2021\n")
                                 
parser.add_argument('--nuc-core-part-id', '-ncpid', action='store', 
                    type=str, required=True, dest="nuc", 
                    help="PDB ID of NCP to model.\n")

parser.add_argument('--ncp-size','-nl', action='store',
                    type=int, required=True, dest="nuc_len", 
                    help="Total length of NCP.\n")
                    
parser.add_argument('--starting-basepair','-bps', action='store',
                    type=int, required=True, dest="nuc_start", 
                    help="Starting base pair of NCP.\n-!-Note: If the base pair is found in entry arm it will be a negative integer.\n")
                    
parser.add_argument('--final-basepair','-bpf', action='store',
                    type=int, required=True, dest="nuc_end", 
                    help="Final base pair of NCP.\n-!-Note: If the base pair is found in entry arm it will be a negative integer.\n")
                    
parser.add_argument('--output-name','-o', action='store',
                    type=str, default="ncp_params", dest="filename", 
                    help="Output name of parameter file (default=ncp_params).\n-!- File extension has already been set to .par\n")
args= parser.parse_args()
# ---------------------------------------------------------------------------------------------------------------


BPDICT={'A':'A-T', 'T':'T-A','C':'C-G','G':'G-C', 
        'a':'A-T', 't':'T-A','c':'C-G','g':'G-C'}

ncp_bp_pars  = pd.read_csv(dbpath+'/ncps_curated_basepairs_ry.csv', index_col=0)
ncp_bps_pars = pd.read_csv(dbpath+'/ncps_curated_steps_ry.csv', index_col=0)

# ---------------------------------------------------------------------------------------------------------------

def main():
    if abs(args.nuc_start)+args.nuc_end+1 != args.nuc_len:
        print("-!- Error: length of NCP does not match length from identified first and last base pair")
    else:
        print("-!- "+str(args.nuc)+' of length '+str(args.nuc_len)+' ---')
        
        NCP_BP  = ncp_bp_pars.copy().loc[(ncp_bp_pars.ncp == args.nuc)
                                         &(ncp_bp_pars.bpindex.isin(np.arange(args.nuc_start, args.nuc_end+1)))].reset_index(drop=True)
        SEQ     = ''.join([NCP_BP.at[i, 'bpname'][0] for i in range(len(NCP_BP))])
        NCP_BP  = NCP_BP[['Shear','Stretch','Stagger','Buckle','PropTw','Opening']]
        
        NCP_BPS = ncp_bps_pars.copy().loc[(ncp_bps_pars.ncp == args.nuc)
                                          &(ncp_bps_pars.stepindex.isin(np.arange(args.nuc_start, args.nuc_end+1)))].reset_index(drop=True)
        NCP_BPS = NCP_BPS[['Shift','Slide','Rise','Tilt','Roll','Twist']].reset_index(drop=True).set_index(np.arange(1, len(NCP_BPS)+1))
        bps_zeros = pd.DataFrame({'Shift':0.,'Slide':0.,'Rise':0.,'Tilt':0.,'Roll':0.,'Twist':0.}, index=[0])
        NCP_BPS = pd.concat([bps_zeros, NCP_BPS])
        NCP_GEN = pd.concat([NCP_BP, NCP_BPS], axis=1)
        del NCP_BP, NCP_BPS
        
        DATA = NCP_GEN[['Shear','Stretch','Stagger','Buckle','PropTw','Opening','Shift','Slide','Rise','Tilt','Roll','Twist']].to_numpy()
        del NCP_GEN
        
        params_writer(DATA, SEQ, args.filename)
        del SEQ, DATA
        

# ---------------------------------------------------------------------------------------------------------------
def params_writer(PARAM_COLLECTION, SEQUENCE, OUTPUTNAME):
    '''
    Needs a 2 line header >'{:>4}'.format(str(len(PARAM_COLLECTION)))+" # base pairs\n  0 # ***local base-pair & step parameters***\n
    line format > {seq:<4} {bp1:>9} {bp2:>9} {bp3:>9} {bp4:>9} {bp5:>9} {bp6:>9} {bps1:>9} {bps2:>9} {bps3:>9} {bps4:>9} {bps5:>9} {bps6:>9}
    first line of this format must be column titles: '#','Shear','Stretch','Stagger','Buckle','Prop-Tw','Opening','Shift','Slide','Rise','Tilt','Roll','Twist'
    '''
    with open(OUTPUTNAME+'.par', 'w') as outfile:
        outfile.write('{}'.format(str(len(PARAM_COLLECTION)))+" # base pairs\n    0 # ***local base-pair & step parameters***\n")
        outfile.write('{:<7} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10}\n'.format('#','Shear','Stretch','Stagger','Buckle','Prop-Tw','Opening','Shift','Slide','Rise','Tilt','Roll','Twist'))

        for i in range(len(PARAM_COLLECTION)):
            outfile.write('{seq:<7} {bp1:>10} {bp2:>10} {bp3:>10} {bp4:>10} {bp5:>10} {bp6:>10} {bps1:>10} {bps2:>10} {bps3:>10} {bps4:>10} {bps5:>10} {bps6:>10}\n'.format(
            seq = BPDICT[SEQUENCE[i:i+1]], 
            bp1 = PARAM_COLLECTION[i][0], bp2=PARAM_COLLECTION[i][1],   bp3=PARAM_COLLECTION[i][2], 
            bp4 = PARAM_COLLECTION[i][3], bp5=PARAM_COLLECTION[i][4],   bp6=PARAM_COLLECTION[i][5], 
            bps1= PARAM_COLLECTION[i][6], bps2=PARAM_COLLECTION[i][7],  bps3=PARAM_COLLECTION[i][8], 
            bps4= PARAM_COLLECTION[i][9], bps5=PARAM_COLLECTION[i][10], bps6=PARAM_COLLECTION[i][11]
            ))
    return


if __name__=="__main__":
    main()


# ---------------------------------------------------------------------------------------------------------------
